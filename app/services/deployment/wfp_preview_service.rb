# Service for ultra-fast preview environments using Workers for Platforms
# Achieves 5-10 second preview provisioning with live reload capability
require "securerandom"

class Deployment::WfpPreviewService
  include HTTParty
  base_uri "https://api.cloudflare.com/client/v4"

  def initialize(app)
    @app = app
    @wfp_service = Deployment::WorkersForPlatformsService.new(@app)
    @account_id = ENV["CLOUDFLARE_ACCOUNT_ID"]
    @api_token = ENV["CLOUDFLARE_API_TOKEN"]

    self.class.headers "Authorization" => "Bearer #{@api_token}"
  end

  # Create preview environment with 5-10 second provisioning
  def create_preview_environment
    start_time = Time.current

    Rails.logger.info "[WfpPreview] Creating preview environment for app #{@app.id} using WFP"

    # Generate the app script for preview environment
    app_script = generate_preview_app_script

    # Deploy app to WFP preview namespace using existing service
    Rails.logger.info "[WfpPreview] Calling @wfp_service.deploy_app with environment: :preview"
    result = @wfp_service.deploy_app(
      app_script,
      environment: :preview,
      metadata: {
        app_id: @app.id,
        deployment_type: "live_preview",
        created_at: Time.current.iso8601
      }
    )

    Rails.logger.info "[WfpPreview] deploy_app returned: #{result.inspect}"
    Rails.logger.info "[WfpPreview] Result class: #{result.class}"

    # Handle deployment result properly
    if result.nil?
      Rails.logger.error "[WfpPreview] WFP service returned nil result!"
      raise "WFP service returned nil result"
    end

    # Check if result is a hash before accessing keys
    unless result.is_a?(Hash)
      Rails.logger.error "[WfpPreview] WFP service returned non-hash result: #{result.inspect}"
      raise "WFP service returned invalid result type: #{result.class}"
    end

    unless result[:success]
      error_msg = result[:error] || result[:message] || "Unknown deployment error"
      Rails.logger.error "[WfpPreview] WFP deployment failed with error: #{error_msg}"
      raise "WFP deployment failed: #{error_msg}"
    end

    deployment_time = Time.current - start_time

    # Use the URL generated by WFP service
    preview_url = result[:url] || result[:deployment_url] || result[:worker_url]

    if preview_url.nil?
      raise "WFP deployment succeeded but no URL returned in result: #{result.keys.join(", ")}"
    end
    websocket_url = preview_url.gsub("https://", "wss://") + "/ws"

    @app.update!(
      preview_url: preview_url,
      preview_websocket_url: websocket_url,
      preview_status: "ready",
      preview_provisioned_at: Time.current,
      preview_deployment_time: deployment_time
    )

    # Upload app files to KV for the app script
    upload_app_files_to_kv

    # Broadcast preview ready via ActionCable
    broadcast_preview_ready(preview_url, websocket_url)

    Rails.logger.info "[WfpPreview] Preview environment created in #{deployment_time.round(2)}s at #{preview_url}"

    {
      preview_url: preview_url,
      websocket_url: websocket_url,
      status: "ready",
      deployment_time: deployment_time.round(2)
    }
  rescue => e
    Rails.logger.error "[WfpPreview] Failed to create preview: #{e.message}"
    @app.update!(preview_status: "error", preview_error: e.message)
    {success: false, error: e.message}
  end

  # Update preview with file changes (for hot reload)
  def update_preview_file(file_path, content)
    Rails.logger.info "[WfpPreview] Updating file #{file_path} in preview"

    # Update file in KV storage for the preview worker
    update_kv_file(file_path, content)

    # Broadcast file update to connected clients via WebSocket
    broadcast_file_update(file_path, content)

    {success: true, file: file_path, updated_at: Time.current}
  end

  private

  def generate_preview_app_script
    <<~JAVASCRIPT
      // OverSkill Live Preview App Script
      // Deployed to WFP namespace and served by dispatch worker
      // Supports hot reload and Supabase integration
      
      export default {
        async fetch(request, env, ctx) {
          const url = new URL(request.url);
          
          // Handle WebSocket upgrade for hot reload
          if (request.headers.get("Upgrade") === "websocket") {
            return handleWebSocketUpgrade(request, env);
          }
          
          // Handle API proxy to Supabase
          if (url.pathname.startsWith('/api/')) {
            return proxyToSupabase(request, env);
          }
          
          // Serve static files from KV
          const file = await getFileFromKV(url.pathname, env);
          if (file) {
            return new Response(file, {
              headers: getContentHeaders(url.pathname)
            });
          }
          
          // Serve index.html for SPA routing with HMR injection
          return serveIndexHtml(env);
        }
      };
      
      async function handleWebSocketUpgrade(request, env) {
        const pair = new WebSocketPair();
        const [client, server] = Object.values(pair);
        
        // Send connection confirmation
        server.send(JSON.stringify({
          type: 'connected',
          appId: '#{@app.id}',
          timestamp: Date.now()
        }));
        
        return new Response(null, {
          status: 101,
          webSocket: client
        });
      }
      
      async function getFileFromKV(pathname, env) {
        // Remove leading slash and handle index
        let filePath = pathname.slice(1) || 'index.html';
        
        // Use app-scoped KV key pattern: app_{app_id}_{file_path}
        const key = 'app_#{@app.id}_' + filePath;
        
        // Try to get file from KV storage
        if (env.PREVIEW_FILES) {
          return await env.PREVIEW_FILES.get(key);
        }
        
        return null;
      }
      
      async function serveIndexHtml(env) {
        // Get index.html from KV or use default
        let html = '';
        if (env.PREVIEW_FILES) {
          const indexKey = 'app_#{@app.id}_index.html';
          html = await env.PREVIEW_FILES.get(indexKey);
        }
        
        if (!html) {
          html = getDefaultHtml();
        }
        
        // Inject HMR client script
        const hmrHtml = html.replace(
          '</body>',
          `<script type="module">
            console.log('ðŸ”¥ OverSkill Live Preview - Hot Reload Active');
            const ws = new WebSocket('wss://' + location.host + '/ws');
            
            ws.onopen = () => console.log('ðŸ”— HMR WebSocket connected');
            ws.onclose = () => console.log('âŒ HMR WebSocket disconnected');
            
            ws.onmessage = (e) => {
              const msg = JSON.parse(e.data);
              console.log('ðŸ“¡ HMR message:', msg);
              
              if (msg.type === 'file-update') {
                console.log('ðŸ”„ Hot reloading:', msg.file);
                location.reload();
              }
            };
          </script></body>`
        );
        
        return new Response(hmrHtml, {
          headers: { 'Content-Type': 'text/html' }
        });
      }
      
      function getDefaultHtml() {
        return `<!DOCTYPE html>
          <html>
            <head>
              <title>OverSkill Preview - App #{@app.id}</title>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <style>
                body { 
                  font-family: system-ui, -apple-system, sans-serif; 
                  display: flex; 
                  align-items: center; 
                  justify-content: center; 
                  height: 100vh;
                  margin: 0;
                  background: linear-gradient(135deg, #667eea, #764ba2);
                  color: white;
                }
                .container {
                  text-align: center;
                  background: rgba(255, 255, 255, 0.1);
                  backdrop-filter: blur(10px);
                  padding: 2rem;
                  border-radius: 12px;
                  border: 1px solid rgba(255, 255, 255, 0.2);
                }
                .spinner {
                  border: 3px solid rgba(255, 255, 255, 0.3);
                  border-top: 3px solid white;
                  border-radius: 50%;
                  width: 30px;
                  height: 30px;
                  animation: spin 1s linear infinite;
                  margin: 0 auto 1rem;
                }
                @keyframes spin {
                  0% { transform: rotate(0deg); }
                  100% { transform: rotate(360deg); }
                }
              </style>
            </head>
            <body>
              <div class="container">
                <div class="spinner"></div>
                <h2>ðŸš€ OverSkill Live Preview</h2>
                <p>App #{@app.id} initializing...</p>
                <p><small>Files are being loaded...</small></p>
              </div>
            </body>
          </html>`;
      }
      
      function getContentHeaders(pathname) {
        // Handle root path and files without extensions as HTML
        if (pathname === '/' || pathname === '/index.html' || !pathname.includes('.')) {
          return {
            'Content-Type': 'text/html',
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'X-OverSkill-App': '#{@app.id}',
            'X-OverSkill-Environment': 'preview'
          };
        }
        
        const ext = pathname.split('.').pop();
        const types = {
          'js': 'application/javascript',
          'jsx': 'application/javascript',
          'ts': 'application/javascript',
          'tsx': 'application/javascript',
          'css': 'text/css',
          'html': 'text/html',
          'json': 'application/json',
          'svg': 'image/svg+xml',
          'png': 'image/png',
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'gif': 'image/gif',
          'ico': 'image/x-icon'
        };
        
        return {
          'Content-Type': types[ext] || 'text/plain',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'X-OverSkill-App': '#{@app.id}',
          'X-OverSkill-Environment': 'preview'
        };
      }
      
      async function proxyToSupabase(request, env) {
        const supabaseUrl = env.SUPABASE_URL || '#{ENV["SUPABASE_URL"]}';
        const supabaseKey = env.SUPABASE_SERVICE_KEY || '#{ENV["SUPABASE_SERVICE_KEY"]}';
        
        if (!supabaseUrl || !supabaseKey) {
          return new Response('Supabase configuration missing', { status: 500 });
        }
        
        // Forward request to Supabase with app isolation
        const url = new URL(request.url);
        url.host = new URL(supabaseUrl).host;
        url.protocol = 'https:';
        
        // Add app isolation headers
        const headers = new Headers(request.headers);
        headers.set('apikey', supabaseKey);
        headers.set('Authorization', 'Bearer ' + supabaseKey);
        headers.set('X-App-Id', '#{@app.id}');
        
        try {
          return await fetch(url.toString(), {
            method: request.method,
            headers: headers,
            body: request.body
          });
        } catch (error) {
          return new Response('Supabase proxy error: ' + error.message, { status: 500 });
        }
      }
    JAVASCRIPT
  end

  # Upload app files to KV storage for preview
  def upload_app_files_to_kv
    namespace_title = "overskill-#{Rails.env}-preview-files"
    namespace_id = get_or_create_kv_namespace(namespace_title)

    # Build app files using the WFP Preview Build Service
    Rails.logger.info "[WfpPreview] Building app #{@app.id} for preview deployment"
    build_service = Deployment::WfpPreviewBuildService.new(@app)
    build_result = build_service.build_for_preview

    files_to_upload = if build_result[:success]
      Rails.logger.info "[WfpPreview] Using built files (#{build_result[:files].count}) for KV upload"
      build_result[:files]
    else
      Rails.logger.warn "[WfpPreview] Build failed: #{build_result[:error]}, falling back to raw source files"
      @app.app_files.map { |f| {path: f.path, content: f.content} }
    end

    Rails.logger.info "[WfpPreview] Uploading #{files_to_upload.count} files to KV namespace #{namespace_id}"

    files_to_upload.each do |file|
      key = "app_#{@app.id}_#{file[:path]}"
      put_kv_value(namespace_id, key, file[:content])
    end

    Rails.logger.info "[WfpPreview] File upload to KV completed"
  end

  def update_kv_file(file_path, content)
    namespace_title = "overskill-#{Rails.env}-preview-files"
    namespace_id = get_or_create_kv_namespace(namespace_title)
    key = "app_#{@app.id}_#{file_path}"

    result = put_kv_value(namespace_id, key, content)
    Rails.logger.info "[WfpPreview] Updated KV file: #{file_path} (success: #{result})"

    {success: result}
  end

  def get_or_create_kv_namespace(title)
    # First try to find existing namespace
    response = self.class.get("/accounts/#{@account_id}/storage/kv/namespaces")

    if response.success?
      existing = response["result"].find { |ns| ns["title"] == title }
      return existing["id"] if existing
    end

    # Create new namespace
    response = self.class.post(
      "/accounts/#{@account_id}/storage/kv/namespaces",
      body: {title: title}.to_json,
      headers: {"Content-Type" => "application/json"}
    )

    if response.success? && response["result"]
      Rails.logger.info "[WfpPreview] Created KV namespace: #{title} with ID #{response["result"]["id"]}"
      response["result"]["id"]
    else
      raise "Failed to create KV namespace: #{response["errors"]}"
    end
  end

  def put_kv_value(namespace_id, key, value)
    response = self.class.put(
      "/accounts/#{@account_id}/storage/kv/namespaces/#{namespace_id}/values/#{key}",
      body: value,
      headers: {"Content-Type" => "text/plain"}
    )

    response.success?
  end

  def broadcast_preview_ready(preview_url, websocket_url)
    # Broadcast via ActionCable that preview is ready
    ActionCable.server.broadcast(
      "app_preview_#{@app.id}",
      {
        type: "preview_ready",
        preview_url: preview_url,
        websocket_url: websocket_url,
        app_id: @app.id,
        timestamp: Time.current
      }
    )
  end

  def broadcast_file_update(file_path, content)
    # Broadcast file update to preview channel
    ActionCable.server.broadcast(
      "app_preview_#{@app.id}",
      {
        type: "file_update",
        file: file_path,
        content: content,
        timestamp: Time.current
      }
    )
  end
end
