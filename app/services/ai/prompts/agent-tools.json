[
    // DYNAMIC VARIABLES (replace with actual values when using this configuration):
    // {{tool_prefix}} - Prefix for all tool names (currently "os-")
    // {{platform_name}} - Name of the platform (currently "OverSkill")
    {
      "description": "Use this tool to add a dependency to the project. The dependency should be a valid npm package name. Usage:\n\n package-name@version\n",
      "name": "os-add-dependency",
      "parameters": {
        "properties": {
          "package": {
            "example": "lodash@latest",
            "type": "string"
          }
        },
        "required": [
          "package"
        ],
        "type": "object"
      }
    },
    {
      "description": "Regex-based code search with file filtering and context.\n\nSearch using regex patterns across files in your project.\n\nParameters:\n- query: Regex pattern to find (e.g., \"useState\")\n- include_pattern: Files to include using glob syntax (e.g., \"src/\")\n- exclude_pattern: Files to exclude using glob syntax (e.g., \"/*.test.tsx\")\n- case_sensitive: Whether to match case (default: false)\n\nTip: Use \\\\ to escape special characters in regex patterns.",
      "name": "os-search-files",
      "parameters": {
        "properties": {
          "case_sensitive": {
            "example": "false",
            "type": "boolean"
          },
          "exclude_pattern": {
            "example": "src/components/ui/",
            "type": "string"
          },
          "include_pattern": {
            "example": "src/",
            "type": "string"
          },
          "query": {
            "example": "useEffect\\(",
            "type": "string"
          }
        },
        "required": [
          "query",
          "include_pattern"
        ],
        "type": "object"
      }
    },
    {
      "description": "\nUse this tool to write to a file. Overwrites the existing file if there is one. The file path should be relative to the project root.\n\n ### IMPORTANT: MINIMIZE CODE WRITING\n - PREFER using os-line-replace for most changes instead of rewriting entire files\n - This tool is mainly meant for creating new files or as fallback if os-line-replace fails\n - When writing is necessary, MAXIMIZE use of \"// ... keep existing code\" to maintain unmodified sections\n - ONLY write the specific sections that need to change - be as lazy as possible with your writes\n \n ### Using \"keep existing code\" (MANDATORY for large unchanged sections):\n - Any unchanged code block over 5 lines MUST use \"// ... keep existing code\" comment\n - The comment MUST contain the EXACT string \"... keep existing code\" \n - Example: \"// ... keep existing code (user interface components)\"\n - NEVER rewrite large sections of code that don't need to change\n \n Example with proper use of keep existing code:\n <os-write file_path=\"src/App.js\">\n import React from 'react';\n import './App.css';\n \n function App() {\n // ... keep existing code (all UI components)\n \n // Only the new footer is being added\n const Footer = () => (\n <footer>New Footer Component</footer>\n );\n \n return (\n <div className=\"App\">\n // ... keep existing code (main content)\n <Footer />\n </div>\n );\n }\n \n export default App;\n \n\n ### Parallel Tool Usage\n - If you need to create multiple files, it is very important that you create all of them at once instead of one by one, because it's much faster\n",
      "name": "os-write",
      "parameters": {
        "properties": {
          "content": {
            "example": "console.log('Hello, World!')",
            "type": "string"
          },
          "file_path": {
            "example": "src/main.ts",
            "type": "string"
          }
        },
        "required": [
          "file_path",
          "content"
        ],
        "type": "object"
      }
    },
    {
      "description": "Line-Based Search and Replace Tool\n\nUse this tool to find and replace specific content in a file you have access to, using explicit line numbers. This is the PREFERRED and PRIMARY tool for editing existing files. Always use this tool when modifying existing code rather than rewriting entire files.\n\nProvide the following details to make an edit:\n\t1.\tfile_path - The path of the file to modify\n\t2.\tsearch - The content to search for (use ellipsis ... for large sections instead of writing them out in full)\n\t3.\tfirst_replaced_line - The line number of the first line in the search (1-indexed)\n\t4.\tlast_replaced_line - The line number of the last line in the search (1-indexed)\n\t5.\treplace - The new content to replace the found content\n\nThe tool will validate that search matches the content at the specified line range and then replace it with replace.\n\nIMPORTANT: When invoking this tool multiple times in parallel (multiple edits to the same file), always use the original line numbers from the file as you initially viewed it. Do not adjust line numbers based on previous edits.\n\nELLIPSIS USAGE:\nWhen replacing sections of code longer than ~6 lines, you should use ellipsis (...) in your search to reduce the number of lines you need to specify (writing fewer lines is faster).\n- Include the first few lines (typically 2-3 lines) of the section you want to replace\n- Add \"...\" on its own line to indicate omitted content\n- Include the last few lines (typically 2-3 lines) of the section you want to replace\n- The key is to provide enough unique context at the beginning and end to ensure accurate matching\n- Focus on uniqueness rather than exact line counts - sometimes 2 lines is enough, sometimes you need 4\n\n\n\nExample:\nTo replace a user card component at lines 22-42:\n\nOriginal content in file (lines 20-45):\n20: return (\n21: <div className=\"user-list\">\n22: <div className=\"user-card\">\n23: <img src={user.avatar} alt=\"User avatar\" />\n24: <h3>{user.name}</h3>\n25: <p>{user.email}</p>\n26: <p>{user.role}</p>\n27: <p>{user.department}</p>\n28: <p>{user.location}</p>\n29: <div className=\"user-actions\">\n30: <button onClick={() => onEdit(user.id)}>Edit</button>\n31: <button onClick={() => onDelete(user.id)}>Delete</button>\n32: <button onClick={() => onView(user.id)}>View</button>\n33: </div>\n34: <div className=\"user-metadata\">\n35: <span>Created: {user.createdAt}</span>\n36: <span>Updated: {user.updatedAt}</span>\n37: <span>Status: {user.status}</span>\n38: </div>\n39: <div className=\"user-permissions\">\n40: <span>Permissions: {user.permissions.join(', ')}</span>\n41: </div>\n42: </div>\n43: </div>\n44: );\n45: }\n\nFor a large replacement like this, you must use ellipsis:\n- search: \" <div className=\\\"user-card\\\">\\n <img src={user.avatar} alt=\\\"User avatar\\\" />\\n...\\n <span>Permissions: {user.permissions.join(', ')}</span>\\n </div>\\n </div>\"\n- first_replaced_line: 22\n- last_replaced_line: 42\n- replace: \" <div className=\\\"user-card enhanced\\\">\\n <div className=\\\"user-avatar\\\">\\n <img \\n src={user.avatar} \\n alt=\\\"User profile picture\\\" \\n className=\\\"avatar-image\\\"\\n onError={(e) => {\\n e.currentTarget.src = '/default-avatar.png';\\n }}\\n />\\n </div>\\n <div className=\\\"user-info\\\">\\n <h3 className=\\\"user-name\\\">{user.name}</h3>\\n <p className=\\\"user-email\\\">{user.email}</p>\\n <div className=\\\"user-details\\\">\\n <span className=\\\"user-role\\\">{user.role}</span>\\n <span className=\\\"user-department\\\">{user.department}</span>\\n </div>\\n </div>\\n <div className=\\\"user-actions\\\">\\n <button \\n className=\\\"edit-button\\\" \\n onClick={() => onEdit(user.id)}\\n aria-label=\\\"Edit user profile\\\"\\n >\\n Edit Profile\\n </button>\\n </div>\\n </div>\"\n\nCritical guidelines:\n\t1. Line Numbers - Specify exact first_replaced_line and last_replaced_line (1-indexed, first line is line 1)\n\t2. Ellipsis Usage - For large sections (>6 lines), use ellipsis (...) to include only the first few and last few key identifying lines for cleaner, more focused matching\n\t3. Content Validation - The prefix and suffix parts of search (before and after ellipsis) must contain exact content matches from the file (without line numbers). The tool validates these parts against the actual file content\n\t4. File Validation - The file must exist and be readable\n\t5. Parallel Tool Calls - When multiple edits are needed, invoke necessary tools simultaneously in parallel. Do NOT wait for one edit to complete before starting the next\n\t6. Original Line Numbers - When making multiple edits to the same file, always use original line numbers from your initial view of the file",
      "name": "os-line-replace",
      "parameters": {
        "properties": {
          "file_path": {
            "example": "src/components/TaskList.tsx",
            "type": "string"
          },
          "first_replaced_line": {
            "description": "First line number to replace (1-indexed)",
            "example": "15",
            "type": "number"
          },
          "last_replaced_line": {
            "description": "Last line number to replace (1-indexed)",
            "example": "28",
            "type": "number"
          },
          "replace": {
            "description": "New content to replace the search content with (without line numbers)",
            "example": " const handleTaskComplete = useCallback((taskId: string) => {\n const updatedTasks = tasks.map(task =>\n task.id === taskId \n ? { ...task, completed: !task.completed, completedAt: new Date() }\n : task\n );\n setTasks(updatedTasks);\n onTaskUpdate?.(updatedTasks);\n \n // Analytics tracking\n analytics.track('task_completed', { taskId, timestamp: Date.now() });\n }, [tasks, onTaskUpdate]);",
            "type": "string"
          },
          "search": {
            "description": "Content to search for in the file (without line numbers). This should match the existing code that will be replaced.",
            "example": " const handleTaskComplete = (taskId: string) => {\n setTasks(tasks.map(task =>\n...\n ));\n onTaskUpdate?.(updatedTasks);\n };",
            "type": "string"
          }
        },
        "required": [
          "file_path",
          "search",
          "first_replaced_line",
          "last_replaced_line",
          "replace"
        ],
        "type": "object"
      }
    },
    {
      "description": "Download a file from a URL and save it to the repository.\n\nThis tool is useful for:\n- Downloading images, assets, or other files from URLs. Download images in the src/assets folder and import them as ES6 modules.\n- Saving external resources directly to the project\n- Migrating files from external sources to the repository\n\nThe file will be downloaded and saved at the specified path in the repository, ready to be used in the project.",
      "name": "os-download-to-repo",
      "parameters": {
        "properties": {
          "source_url": {
            "description": "The URL of the file to download",
            "example": "https://example.com/image.png",
            "type": "string"
          },
          "target_path": {
            "description": "The path where the file should be saved in the repository (use the public folder unless specified otherwise)",
            "example": "public/images/logo.png",
            "type": "string"
          }
        },
        "required": [
          "source_url",
          "target_path"
        ],
        "type": "object"
      }
    },
    {
      "description": "Fetches a website and temporarily saves its content (markdown, HTML, screenshot) to files in `tmp://fetched-websites/`. Returns the paths to the created files and a preview of the content.",
      "name": "os-fetch-website",
      "parameters": {
        "properties": {
          "formats": {
            "description": "Comma-separated list of formats to return. Supported formats: 'markdown', 'html', 'screenshot'. Defaults to 'markdown'.",
            "example": "markdown,screenshot",
            "type": "string"
          },
          "url": {
            "example": "https://example.com",
            "type": "string"
          }
        },
        "required": [
          "url"
        ],
        "type": "object"
      }
    },
    {
      "description": "Use this tool to read the contents of a file. The file path should be relative to the project root. You can optionally specify line ranges to read using the lines parameter (e.g., \"1-800, 1001-1500\"). By default, the first 500 lines are read if lines is not specified.\n\nIMPORTANT GUIDELINES:\n- Do NOT use this tool if the file contents have already been provided in the context\n- Do NOT specify line ranges unless the file is very large (>500 lines) - rely on the default behavior which shows the first 500 lines\n- Only use line ranges when you need to see specific sections of large files that weren't shown in the default view\n- If you need to read multiple files, invoke this tool multiple times in parallel (not sequentially) for efficiency",
      "name": "os-view",
      "parameters": {
        "properties": {
          "file_path": {
            "example": "src/App.tsx",
            "type": "string"
          },
          "lines": {
            "example": "1-800, 1001-1500",
            "type": "string"
          }
        },
        "required": [
          "file_path"
        ],
        "type": "object"
      }
    },
    {
      "description": "Use this tool to read the contents of the latest console logs at the moment the user sent the request.\nYou can optionally provide a search query to filter the logs. If empty you will get all latest logs.\nYou may not be able to see the logs that didn't happen recently.\nThe logs will not update while you are building and writing code. So do not expect to be able to verify if you fixed an issue by reading logs again. They will be the same as when you started writing code.\nDO NOT USE THIS MORE THAN ONCE since you will get the same logs each time.",
      "name": "os-read-console-logs",
      "parameters": {
        "properties": {
          "search": {
            "example": "error",
            "type": "string"
          }
        },
        "required": [
          "search"
        ],
        "type": "object"
      }
    },
    {
      "description": "Use this tool to read the contents of the latest network requests. You can optionally provide a search query to filter the requests. If empty you will get all latest requests. You may not be able to see the requests that didn't happen recently.",
      "name": "os-read-network-requests",
      "parameters": {
        "properties": {
          "search": {
            "example": "error",
            "type": "string"
          }
        },
        "required": [
          "search"
        ],
        "type": "object"
      }
    },
    {
      "description": "Use this tool to uninstall a package from the project.",
      "name": "os-remove-dependency",
      "parameters": {
        "properties": {
          "package": {
            "example": "lodash",
            "type": "string"
          }
        },
        "required": [
          "package"
        ],
        "type": "object"
      }
    },
    {
      "description": "You MUST use this tool to rename a file instead of creating new files and deleting old ones. The original and new file path should be relative to the project root.",
      "name": "os-rename",
      "parameters": {
        "properties": {
          "new_file_path": {
            "example": "src/main_new2.ts",
            "type": "string"
          },
          "original_file_path": {
            "example": "src/main.ts",
            "type": "string"
          }
        },
        "required": [
          "original_file_path",
          "new_file_path"
        ],
        "type": "object"
      }
    },
    {
      "description": "Use this tool to delete a file. The file path should be relative to the project root.",
      "name": "os-delete",
      "parameters": {
        "properties": {
          "file_path": {
            "example": "src/App.tsx",
            "type": "string"
          }
        },
        "required": [
          "file_path"
        ],
        "type": "object"
      }
    },
    {
      "description": "Generates an image based on a text prompt and saves it to the specified file path. Use the best models for large images that are really important. Make sure that you consider aspect ratio given the location of the image on the page when selecting dimensions.\n\nFor small images (less than 1000px), use flux.schnell, it's much faster and really good! This should be your default model.\nWhen you generate large images like a fullscreen image, use flux.dev. The maximum resolution is 1920x1920.\nOnce generated, you need to import the images in code as ES6 imports.\n\nPrompting tips:\n- Mentioning the aspect ratio in the prompt will help the model generate the image with the correct dimensions. For example: \"A 16:9 aspect ratio image of a sunset over a calm ocean.\"\n- Use the \"Ultra high resolution\" suffix to your prompts to maximize image quality.\n- If you for example are generating a hero image, mention it in the prompt. Example: \"A hero image of a sunset over a calm ocean.\"\n\nExample:\nimport heroImage from \"@/assets/hero-image.jpg\";\n\nImportant: Dimensions must be between 512 and 1920 pixels and multiples of 32.",
      "name": "generate_image",
      "parameters": {
        "properties": {
          "height": {
            "description": "Image height (minimum 512, maximum 1920)",
            "type": "number"
          },
          "model": {
            "description": "The model to use for generation. Options: flux.schnell (default), flux.dev. flux.dev generates higher quality images but is slower. Always use flux.schnell unless you're generating a large image like a hero image or fullscreen banner, of if the user asks for high quality.",
            "type": "string"
          },
          "prompt": {
            "description": "Text description of the desired image",
            "type": "string"
          },
          "target_path": {
            "description": "The file path where the generated image should be saved. Prefer to put them in the 'src/assets' folder.",
            "type": "string"
          },
          "width": {
            "description": "Image width (minimum 512, maximum 1920)",
            "type": "number"
          }
        },
        "required": [
          "prompt",
          "target_path"
        ],
        "type": "object"
      }
    },
    {
      "description": "Edits or merges existing images based on a text prompt using Flux Kontext Pro model.\nThis tool can work with single or multiple images:\n- Single image: Apply AI-powered edits based on your prompt\n- Multiple images: Merge/combine images according to your prompt\n\nThe strength parameter controls how much the image changes (0.0-1.0).\nLower values preserve more of the original image structure.\n\nExample prompts for single image:\n- \"make it rainy\"\n- \"change to sunset lighting\"\n- \"add snow\"\n- \"make it more colorful\"\n\nExample prompts for multiple images:\n- \"blend these two landscapes seamlessly\"\n- \"combine the foreground of the first image with the background of the second\"\n- \"merge these portraits into a group photo\"\n- \"create a collage from these images\"\n\n\nThis tool is great for object or character consistency. You can reuse the same image and place it in different scenes for example.",
      "name": "edit_image",
      "parameters": {
        "properties": {
          "image_paths": {
            "description": "Array of paths to existing image files. For single image editing, provide one path. For merging/combining multiple images, provide multiple paths.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "prompt": {
            "description": "Text description of how to edit/merge the image(s). For multiple images, describe how they should be combined.",
            "type": "string"
          },
          "strength": {
            "description": "How much to change the image (0.0-1.0). Lower values preserve more of the original image.",
            "type": "number"
          },
          "target_path": {
            "description": "The file path where the edited/merged image should be saved.",
            "type": "string"
          }
        },
        "required": [
          "image_paths",
          "prompt",
          "target_path"
        ],
        "type": "object"
      }
    },
    {
      "description": "Performs a web search using SerpAPI and returns multiple relevant results with text snippets.\n\n**WHEN TO USE web_search:**\n- Finding multiple relevant pages across the web (discovery phase)\n- Getting quick overview of a topic from multiple sources\n- Finding specific types of content (news, GitHub, LinkedIn profiles, PDFs)\n- When you need breadth over depth (multiple perspectives)\n- Finding real images about people, companies, or organizations\n- Quick fact-finding from search result snippets\n\n**ADVANTAGES:**\n- Fast and inexpensive (SerpAPI pricing)\n- Returns multiple results (typically 5-10)\n- Good for discovery and exploration\n- Includes metadata (titles, URLs, snippets)\n\n**LIMITATIONS:**\n- Only returns ~200 character snippets per result\n- Cannot read full page content\n- May miss detailed information within pages\n\n**COST:** Low - SerpAPI credits only",
      "name": "web_search",
      "parameters": {
        "properties": {
          "category": {
            "description": "Category of search results to return",
            "type": "string"
          },
          "imageLinks": {
            "description": "Number of image links to return for each result",
            "type": "number"
          },
          "links": {
            "description": "Number of links to return for each result",
            "type": "number"
          },
          "numResults": {
            "description": "Number of search results to return (default: 5)",
            "type": "number"
          },
          "query": {
            "description": "The search query",
            "type": "string"
          }
        },
        "required": [
          "query"
        ],
        "type": "object"
      }
    },
    {
      "description": "Fetch and extract clean content from a specific webpage URL using traditional scraping.\n\n**WHEN TO USE os-fetch-webpage:**\n- Reading COMPLETE content from a specific URL (after finding it with web_search)\n- Extracting full documentation, articles, or technical specifications\n- When user provides a specific URL to analyze\n- When you need the exact page content without AI interpretation\n- Following up on search results for deep reading\n\n**ADVANTAGES:**\n- Gets complete page content (up to 100k chars)\n- Preserves exact text without AI modification\n- Uses readability algorithm to extract main content\n- Very low cost (bandwidth only)\n- 1-hour Redis cache for repeat requests\n\n**LIMITATIONS:**\n- Only works with single URLs (not topics)\n- May fail on JavaScript-heavy sites\n- Cannot synthesize information from multiple sources\n- No automatic citations or source verification\n\n**COST:** Minimal - bandwidth and processing only\n\n**PROCESS:**\n1. Fetches webpage HTML\n2. Extracts main article using readability algorithm\n3. Removes ads, navigation, sidebars\n4. Converts to clean plain text\n5. Returns up to 100k characters",
      "name": "os-fetch-webpage",
      "parameters": {
        "properties": {
          "url": {
            "description": "The complete URL of the webpage to fetch",
            "example": "https://docs.example.com/api/authentication",
            "type": "string"
          },
          "use_cache": {
            "description": "Whether to use cached content if available (default: true)",
            "example": true,
            "type": "boolean"
          }
        },
        "required": [
          "url"
        ],
        "type": "object"
      }
    },
    {
      "description": "AI-powered web research using Perplexity for comprehensive, real-time information synthesis.\n\n**WHEN TO USE perplexity-research:**\n- Researching topics (not specific URLs) that need current information\n- When you need AI-synthesized insights from multiple sources\n- Fact-checking statements with automatic citations\n- Deep research requiring chain-of-thought reasoning\n- When dealing with complex questions needing multiple perspectives\n- Getting around-the-clock updated information (real-time web access)\n\n**ADVANTAGES:**\n- AI synthesizes information from 20+ sources automatically\n- Provides citations with every response\n- Real-time, current information (not limited by training cutoff)\n- Can handle research questions, not just URLs\n- Multiple AI models for different needs (sonar, sonar-pro, deep-research)\n- Bypasses many anti-scraping protections\n\n**LIMITATIONS:**\n- HIGH COST WARNING: 30-40x more expensive than direct scraping\n- Each query retrieves ~20 citations, multiplying token costs\n- Can cost $0.10+ per query vs $0.003 for traditional methods\n- AI interpretation may alter original content meaning\n- Not suitable for high-volume operations\n\n**COST:** High - $3-10 per million tokens + hidden citation costs\n\n**AVAILABLE MODES:**\n- 'quick': Fast facts with sonar model ($3/$15 per M tokens)\n- 'research': Comprehensive research with sonar-pro ($3/$15 per M tokens)\n- 'deep': Multi-query deep research ($10/$40 per M tokens)\n- 'fact_check': Verify statements with citations\n\n**USE CASES:**\n1. Research complex topics: 'How do modern LLMs handle context windows?'\n2. Fact-check claims: 'Is GPT-5 really 10x faster than GPT-4?'\n3. Current events: 'Latest developments in AI regulation 2025'\n4. Multi-source synthesis: 'Compare React vs Vue performance in 2025'",
      "name": "perplexity-research",
      "parameters": {
        "properties": {
          "query": {
            "description": "Topic, question, URL, or statement to research",
            "example": "Latest React 19 performance improvements",
            "type": "string"
          },
          "mode": {
            "description": "Research mode: 'quick' (fast facts), 'research' (comprehensive), 'deep' (multi-query), 'fact_check' (verify claims)",
            "example": "research",
            "type": "string"
          },
          "max_tokens": {
            "description": "Maximum response tokens (default: 2000, max: 4000 for deep mode)",
            "example": 2000,
            "type": "number"
          },
          "use_cache": {
            "description": "Use cached results if available (default: true)",
            "example": true,
            "type": "boolean"
          }
        },
        "required": [
          "query"
        ],
        "type": "object"
      }
    },
    {
      "description": "Read the analytics for the production build of the project between two dates, with a given granularity. The granularity can be 'hourly' or 'daily'. The start and end dates must be in the format YYYY-MM-DD.\nThe start and end dates should be in RFC3339 format or date only format (YYYY-MM-DD).\n\nWhen to use this tool:\n- When the user is asking for usage of their app\n- When users want to improve their productions apps",
      "name": "read_project_analytics",
      "parameters": {
        "properties": {
          "enddate": {
            "type": "object"
          },
          "granularity": {
            "type": "string"
          },
          "startdate": {
            "type": "object"
          }
        },
        "required": [
          "startdate",
          "enddate",
          "granularity"
        ],
        "type": "object"
      }
    },
    {
      "description": "Rename the current app with a new name and automatically generate a URL-safe subdomain slug.\n\nUse this tool when:\n- The user asks to rename the app\n- You need to give the app a more descriptive or appropriate name\n- The app name should reflect its functionality or purpose\n- During initial app setup to set a proper name\n\nThe subdomain will be automatically generated from the name (e.g., 'My Cool App' becomes 'my-cool-app').\nNote: The subdomain must be unique across the platform.",
      "name": "rename-app",
      "parameters": {
        "properties": {
          "name": {
            "description": "The new display name for the app",
            "example": "Elite Roofing Solutions",
            "type": "string"
          },
          "subdomain": {
            "description": "Optional: Custom subdomain slug. If not provided, will be generated from name",
            "example": "elite-roofing",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      }
    },
    {
      "description": "Generate a new AI-powered logo for the app based on its name and description.\n\nUse this tool when:\n- The user asks for a new logo\n- The app needs a visual identity\n- During initial app setup after naming\n- The app's purpose has changed significantly\n\nThe logo will be generated as a modern, minimalist app icon suitable for web and mobile.\nIt will be automatically saved and set as the app's logo.",
      "name": "generate-new-app-logo",
      "parameters": {
        "properties": {
          "style": {
            "description": "Optional: Style preference for the logo",
            "enum": ["modern", "minimalist", "playful", "professional", "bold", "elegant"],
            "example": "modern",
            "type": "string"
          },
          "colors": {
            "description": "Optional: Preferred color scheme",
            "example": "blue and white",
            "type": "string"
          }
        },
        "required": [],
        "type": "object"
      }
    }
  ]