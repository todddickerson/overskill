class Cloudflare::WorkerGeneratorService
  def initialize(app)
    @app = app
  end
  
  def generate_oauth_worker(provider:, redirect_uri:)
    case provider.to_s
    when 'google'
      generate_google_oauth_worker(redirect_uri)
    when 'github'
      generate_github_oauth_worker(redirect_uri)
    when 'auth0'
      generate_auth0_oauth_worker(redirect_uri)
    else
      raise ArgumentError, "Unsupported OAuth provider: #{provider}"
    end
  end
  
  def generate_api_proxy_worker(api_config)
    template = File.read(Rails.root.join('app', 'services', 'cloudflare', 'templates', 'api_proxy_worker.js'))
    
    ERB.new(template).result(binding)
  end
  
  private
  
  def generate_google_oauth_worker(redirect_uri)
    worker_code = <<~JAVASCRIPT
      // Google OAuth Worker for App: #{@app.name}
      // Generated by OverSkill - #{Time.current}
      
      export default {
        async fetch(request, env, ctx) {
          const url = new URL(request.url);
          const corsHeaders = {
            'Access-Control-Allow-Origin': '#{@app.preview_url}',
            'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
            'Access-Control-Max-Age': '86400',
          };
          
          // Handle CORS preflight
          if (request.method === 'OPTIONS') {
            return new Response(null, { headers: corsHeaders });
          }
          
          try {
            // OAuth initiation
            if (url.pathname === '/auth/google') {
              const authUrl = new URL('https://accounts.google.com/o/oauth2/v2/auth');
              authUrl.searchParams.set('client_id', env.GOOGLE_CLIENT_ID);
              authUrl.searchParams.set('redirect_uri', '#{redirect_uri}');
              authUrl.searchParams.set('response_type', 'code');
              authUrl.searchParams.set('scope', 'openid email profile');
              authUrl.searchParams.set('state', generateState());
              
              return Response.redirect(authUrl.toString(), 302);
            }
            
            // OAuth callback handling
            if (url.pathname === '/auth/google/callback') {
              const code = url.searchParams.get('code');
              const state = url.searchParams.get('state');
              
              if (!code) {
                return new Response('Authorization code missing', { 
                  status: 400, 
                  headers: corsHeaders 
                });
              }
              
              // Exchange code for tokens
              const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({
                  client_id: env.GOOGLE_CLIENT_ID,
                  client_secret: env.GOOGLE_CLIENT_SECRET,
                  code: code,
                  grant_type: 'authorization_code',
                  redirect_uri: '#{redirect_uri}'
                })
              });
              
              const tokens = await tokenResponse.json();
              
              if (!tokenResponse.ok) {
                return new Response(JSON.stringify({ 
                  error: 'Token exchange failed', 
                  details: tokens 
                }), { 
                  status: 400, 
                  headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
              }
              
              // Get user info
              const userResponse = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                headers: { 'Authorization': `Bearer ${tokens.access_token}` }
              });
              
              const userInfo = await userResponse.json();
              
              return new Response(JSON.stringify({
                success: true,
                user: userInfo,
                tokens: {
                  access_token: tokens.access_token,
                  refresh_token: tokens.refresh_token,
                  expires_in: tokens.expires_in
                }
              }), {
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
              });
            }
            
            // Token refresh endpoint
            if (url.pathname === '/auth/google/refresh' && request.method === 'POST') {
              const { refresh_token } = await request.json();
              
              const refreshResponse = await fetch('https://oauth2.googleapis.com/token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({
                  client_id: env.GOOGLE_CLIENT_ID,
                  client_secret: env.GOOGLE_CLIENT_SECRET,
                  refresh_token: refresh_token,
                  grant_type: 'refresh_token'
                })
              });
              
              const tokens = await refreshResponse.json();
              
              return new Response(JSON.stringify(tokens), {
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
              });
            }
            
            return new Response('Not Found', { status: 404, headers: corsHeaders });
            
          } catch (error) {
            console.error('OAuth Worker Error:', error);
            return new Response(JSON.stringify({ 
              error: 'Internal server error',
              message: error.message 
            }), { 
              status: 500, 
              headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
          }
        }
      };
      
      function generateState() {
        return Array.from(crypto.getRandomValues(new Uint8Array(16)))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
      }
    JAVASCRIPT
    
    worker_code
  end
  
  def generate_github_oauth_worker(redirect_uri)
    worker_code = <<~JAVASCRIPT
      // GitHub OAuth Worker for App: #{@app.name}
      // Generated by OverSkill - #{Time.current}
      
      export default {
        async fetch(request, env, ctx) {
          const url = new URL(request.url);
          const corsHeaders = {
            'Access-Control-Allow-Origin': '#{@app.preview_url}',
            'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
            'Access-Control-Max-Age': '86400',
          };
          
          if (request.method === 'OPTIONS') {
            return new Response(null, { headers: corsHeaders });
          }
          
          try {
            // OAuth initiation
            if (url.pathname === '/auth/github') {
              const authUrl = new URL('https://github.com/login/oauth/authorize');
              authUrl.searchParams.set('client_id', env.GITHUB_CLIENT_ID);
              authUrl.searchParams.set('redirect_uri', '#{redirect_uri}');
              authUrl.searchParams.set('scope', 'user:email');
              authUrl.searchParams.set('state', generateState());
              
              return Response.redirect(authUrl.toString(), 302);
            }
            
            // OAuth callback handling
            if (url.pathname === '/auth/github/callback') {
              const code = url.searchParams.get('code');
              
              if (!code) {
                return new Response('Authorization code missing', { 
                  status: 400, 
                  headers: corsHeaders 
                });
              }
              
              // Exchange code for tokens
              const tokenResponse = await fetch('https://github.com/login/oauth/access_token', {
                method: 'POST',
                headers: { 
                  'Accept': 'application/json',
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  client_id: env.GITHUB_CLIENT_ID,
                  client_secret: env.GITHUB_CLIENT_SECRET,
                  code: code
                })
              });
              
              const tokens = await tokenResponse.json();
              
              if (!tokens.access_token) {
                return new Response(JSON.stringify({ 
                  error: 'Token exchange failed', 
                  details: tokens 
                }), { 
                  status: 400, 
                  headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
              }
              
              // Get user info
              const userResponse = await fetch('https://api.github.com/user', {
                headers: { 
                  'Authorization': `Bearer ${tokens.access_token}`,
                  'User-Agent': 'OverSkill-App'
                }
              });
              
              const userInfo = await userResponse.json();
              
              return new Response(JSON.stringify({
                success: true,
                user: userInfo,
                tokens: {
                  access_token: tokens.access_token,
                  token_type: tokens.token_type,
                  scope: tokens.scope
                }
              }), {
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
              });
            }
            
            return new Response('Not Found', { status: 404, headers: corsHeaders });
            
          } catch (error) {
            console.error('GitHub OAuth Worker Error:', error);
            return new Response(JSON.stringify({ 
              error: 'Internal server error',
              message: error.message 
            }), { 
              status: 500, 
              headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
          }
        }
      };
      
      function generateState() {
        return Array.from(crypto.getRandomValues(new Uint8Array(16)))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
      }
    JAVASCRIPT
    
    worker_code
  end
  
  def generate_auth0_oauth_worker(redirect_uri)
    worker_code = <<~JAVASCRIPT
      // Auth0 OAuth Worker for App: #{@app.name}
      // Generated by OverSkill - #{Time.current}
      
      export default {
        async fetch(request, env, ctx) {
          const url = new URL(request.url);
          const corsHeaders = {
            'Access-Control-Allow-Origin': '#{@app.preview_url}',
            'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
            'Access-Control-Max-Age': '86400',
          };
          
          if (request.method === 'OPTIONS') {
            return new Response(null, { headers: corsHeaders });
          }
          
          try {
            // OAuth initiation
            if (url.pathname === '/auth/auth0') {
              const authUrl = new URL(`https://${env.AUTH0_DOMAIN}/authorize`);
              authUrl.searchParams.set('response_type', 'code');
              authUrl.searchParams.set('client_id', env.AUTH0_CLIENT_ID);
              authUrl.searchParams.set('redirect_uri', '#{redirect_uri}');
              authUrl.searchParams.set('scope', 'openid profile email');
              authUrl.searchParams.set('state', generateState());
              
              return Response.redirect(authUrl.toString(), 302);
            }
            
            // OAuth callback handling
            if (url.pathname === '/auth/auth0/callback') {
              const code = url.searchParams.get('code');
              
              if (!code) {
                return new Response('Authorization code missing', { 
                  status: 400, 
                  headers: corsHeaders 
                });
              }
              
              // Exchange code for tokens
              const tokenResponse = await fetch(`https://${env.AUTH0_DOMAIN}/oauth/token`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  grant_type: 'authorization_code',
                  client_id: env.AUTH0_CLIENT_ID,
                  client_secret: env.AUTH0_CLIENT_SECRET,
                  code: code,
                  redirect_uri: '#{redirect_uri}'
                })
              });
              
              const tokens = await tokenResponse.json();
              
              if (!tokenResponse.ok) {
                return new Response(JSON.stringify({ 
                  error: 'Token exchange failed', 
                  details: tokens 
                }), { 
                  status: 400, 
                  headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
              }
              
              // Get user info
              const userResponse = await fetch(`https://${env.AUTH0_DOMAIN}/userinfo`, {
                headers: { 'Authorization': `Bearer ${tokens.access_token}` }
              });
              
              const userInfo = await userResponse.json();
              
              return new Response(JSON.stringify({
                success: true,
                user: userInfo,
                tokens: {
                  access_token: tokens.access_token,
                  id_token: tokens.id_token,
                  refresh_token: tokens.refresh_token,
                  expires_in: tokens.expires_in
                }
              }), {
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
              });
            }
            
            return new Response('Not Found', { status: 404, headers: corsHeaders });
            
          } catch (error) {
            console.error('Auth0 OAuth Worker Error:', error);
            return new Response(JSON.stringify({ 
              error: 'Internal server error',
              message: error.message 
            }), { 
              status: 500, 
              headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
          }
        }
      };
      
      function generateState() {
        return Array.from(crypto.getRandomValues(new Uint8Array(16)))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
      }
    JAVASCRIPT
    
    worker_code
  end
end