// API Proxy Worker for App: <%= @app.name %>
// Generated by OverSkill - <%= Time.current %>

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const corsHeaders = {
      'Access-Control-Allow-Origin': '<%= @app.preview_url %>',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-API-Key',
      'Access-Control-Max-Age': '86400',
    };

    // Handle CORS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      <% api_config.each do |config| %>
      // <%= config[:name] %> API Proxy
      if (url.pathname.startsWith('/<%= config[:path] %>')) {
        return await proxyTo<%= config[:name].camelize %>(request, env, url);
      }
      <% end %>

      return new Response('API endpoint not found', { 
        status: 404, 
        headers: corsHeaders 
      });

    } catch (error) {
      console.error('API Proxy Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal server error',
        message: error.message 
      }), { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
  }
};

<% api_config.each do |config| %>
// <%= config[:name] %> API Handler
async function proxyTo<%= config[:name].camelize %>(request, env, url) {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '<%= @app.preview_url %>',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-API-Key',
  };

  // Remove our proxy path prefix
  const targetPath = url.pathname.replace('/<%= config[:path] %>', '');
  const targetUrl = '<%= config[:base_url] %>' + targetPath + url.search;

  // Build headers for the target API
  const headers = new Headers();
  
  <% if config[:auth_type] == 'bearer' %>
  headers.set('Authorization', `Bearer ${env.<%= config[:env_key] %>}`);
  <% elsif config[:auth_type] == 'api_key' %>
  headers.set('<%= config[:api_key_header] || 'X-API-Key' %>', env.<%= config[:env_key] %>);
  <% elsif config[:auth_type] == 'custom' %>
  <%= config[:custom_auth_code] %>
  <% end %>

  // Copy relevant headers from the original request
  const allowedHeaders = ['content-type', 'accept', 'user-agent'];
  allowedHeaders.forEach(header => {
    const value = request.headers.get(header);
    if (value) {
      headers.set(header, value);
    }
  });

  <% if config[:additional_headers] %>
  // Add custom headers
  <% config[:additional_headers].each do |key, value| %>
  headers.set('<%= key %>', '<%= value %>');
  <% end %>
  <% end %>

  // Forward the request
  const proxyRequest = new Request(targetUrl, {
    method: request.method,
    headers: headers,
    body: request.method !== 'GET' && request.method !== 'HEAD' ? await request.blob() : null
  });

  const response = await fetch(proxyRequest);

  // Create response with CORS headers
  const responseBody = await response.text();
  
  return new Response(responseBody, {
    status: response.status,
    statusText: response.statusText,
    headers: {
      ...corsHeaders,
      'Content-Type': response.headers.get('Content-Type') || 'application/json',
      // Forward relevant response headers
      ...(response.headers.get('cache-control') && {
        'Cache-Control': response.headers.get('cache-control')
      }),
      ...(response.headers.get('x-ratelimit-remaining') && {
        'X-RateLimit-Remaining': response.headers.get('x-ratelimit-remaining')
      }),
    }
  });
}

<% end %>

// Utility functions
function isValidOrigin(origin, allowedOrigin) {
  if (allowedOrigin === '*') return true;
  if (allowedOrigin === origin) return true;
  
  // Support wildcard subdomains like *.example.com
  if (allowedOrigin.startsWith('*.')) {
    const domain = allowedOrigin.slice(2);
    return origin.endsWith('.' + domain) || origin === domain;
  }
  
  return false;
}

function sanitizeHeaders(headers) {
  const sanitized = new Headers();
  const allowed = [
    'content-type', 'authorization', 'x-api-key', 
    'accept', 'user-agent', 'cache-control'
  ];
  
  for (const [key, value] of headers.entries()) {
    if (allowed.includes(key.toLowerCase())) {
      sanitized.set(key, value);
    }
  }
  
  return sanitized;
}